<!DOCTYPE html><html lang="en" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="[수치해석] 뉴턴 다항식 보간법" /><meta property="og:locale" content="en" /><meta name="description" content="뉴턴 다항식 보간법에 대한 원리, 방법, 알고리즘을 설명한다." /><meta property="og:description" content="뉴턴 다항식 보간법에 대한 원리, 방법, 알고리즘을 설명한다." /><link rel="canonical" href="https://devslem.github.io/numerical-analysis/newton-polynomial/" /><meta property="og:url" content="https://devslem.github.io/numerical-analysis/newton-polynomial/" /><meta property="og:site_name" content="DevSlem Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-12-11T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[수치해석] 뉴턴 다항식 보간법" /><meta name="google-site-verification" content="SSJwUK1JSPZV3wjQS19f2bXfHYIupbYEFsisH4Nuns4" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-06-25T00:00:00+09:00","datePublished":"2021-12-11T00:00:00+09:00","description":"뉴턴 다항식 보간법에 대한 원리, 방법, 알고리즘을 설명한다.","headline":"[수치해석] 뉴턴 다항식 보간법","mainEntityOfPage":{"@type":"WebPage","@id":"https://devslem.github.io/numerical-analysis/newton-polynomial/"},"url":"https://devslem.github.io/numerical-analysis/newton-polynomial/"}</script><title>[수치해석] 뉴턴 다항식 보간법 | DevSlem Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="DevSlem Blog"><meta name="application-name" content="DevSlem Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> </a></div><div class="site-title mt-3"> <a href="/">DevSlem Blog</a></div><div class="site-subtitle font-italic">It's a blog where i write posts about AI, RL, Unity, etc.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/DevSlem" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['devslem12','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[수치해석] 뉴턴 다항식 보간법</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[수치해석] 뉴턴 다항식 보간법</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1639148400" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Dec 11, 2021 </em> </span> <span> Updated <em class="" data-ts="1656115200" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jun 25, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/username">DevSlem</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6339 words"> <em>35 min</em> read</span></div></div></div><div class="post-content"><h2 id="introduction"><span class="mr-2">Introduction</span><a href="#introduction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>당연하지만 프로그래밍에서 <strong>보간법(Interpolation)</strong>은 굉장히 중요한 영역이다. 주어진 데이터는 한정적이지만 우리가 예측해야하는 범위는 너무 넓다. 그래서 필요한 것이 보간법 (Interpolation)이다. 예를 들면 다음과 같은 점의 위치를 우리가 이미 알고 있거나 주어졌다고 하자.</p>\[(-1, 0), (0, 0), (1, 0), (2, 6)\]<p>위 점을 지나는 함수는 아래와 같다.</p>\[y = x(x - 1)(x + 1)\]<p>위 함수의 그래프:</p><p><img data-src="/assets/images/cubic-function.png" alt="3차함수" width="60%" data-proofer-ignore></p><p>위 그림에서 빨간색 점이 우리가 이미 알고 있는 점이고, 위 점을 지나는 유일한 다항함수의 모습은 위와 같은 형태이다.</p><p>위 그림의 예처럼 어떠한 데이터가 주어져있을 때 이 데이터들로 <strong>부드러운 곡선</strong>을 그려 데이터들의 사이값을 예측하고 싶다. 즉, 각 점을 지나는 <strong>비선형 함수</strong>를 구하고 싶다. 어떤 점들을 지나는 함수를 알 수 있다면 다양하게 활용할 수 있다. 데이터들을 비선형 함수로 보간하는 방법은 여러 개가 있겠지만 여기서는 가장 기초적인 <strong>다항식 보간</strong>에 대해 설명하려고 한다.</p><p>다항식 보간에는 여러가지가 있다. 가장 간단한 방법으로는 주어진 데이터를 가지고 $p(x) = a_0 + a_1x + a_2x^2 + \cdots$ 형태의 방정식을 푸는 게 가장 쉬운 방식이라고 할 수 있다. 행렬을 활용하면 프로그래밍으로 쉽게 각 항의 계수를 구할 수 있다. 이 방법을 <a href="https://en.wikipedia.org/wiki/Polynomial_interpolation#Constructing_the_interpolation_polynomial">Monomial basis 다항식 보간법</a>이라고 한다. 하지만 이 방식에는 몇가지 문제점이 존재하기 때문에 (대표적으로 조건 상수 값이 너무 큼) 다른 다항식 보간법인 <a href="https://en.wikipedia.org/wiki/Newton_polynomial">뉴턴 다항식 보간법(Newton Polynomial Interpolation)</a>을 소개하려고 한다.</p><h2 id="definition"><span class="mr-2">Definition</span><a href="#definition" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>먼저 미리 말하지만 아래 정의만 보면 무슨 소리인지 이해하기 어려울 것이다. <strong>당황해서 뒤로가기 누르지 말고 가볍게 보기</strong>를 권장한다. $n + 1$개의 Point에 대한 데이터 집합이 아래와 같이 주어져 있다고 하자.</p>\[(x_0, y_0), (x_1, y_1), \cdots, (x_n, y_n)\]<p>위 $n + 1$개의 Point 중 $x$ 좌표가 모두 다르다면 뉴턴 다항식은 다음과 같이 정의될 수 있다.</p>\[N(x) = \displaystyle\sum_{i = 0}^{n}a_i p_i(x)\]<p>$p_i(x)$는 Newton basis polynomials (뉴턴 기반 다항식)이며 아래와 같이 정의된다.</p>\[p_i(x) = \displaystyle\prod_{k = 0}^{i - 1}(x - x_k)\]<p>다항식의 형식이 변수 $x$에서 위 Point의 $x$좌표를 뺀 항들끼리 곱해지는 형태이다.<br /> 이 때 주의깊게 볼 점은 $i$번 째 뉴턴 기반 다항식에 대해서 $i - 1$번째까지의 $x$좌표를 참조한다. 이를 유의해야 한다.</p><p>각 항의 계수 $a_i$는 <a href="https://en.wikipedia.org/wiki/Divided_differences">Divided differences(분할 차분)</a>이며 아래와 같이 정의된다.</p>\[f[x_k] = f(x_k)\] \[f[x_k, x_{k + 1}, \cdots, x_l] = \displaystyle\frac{f[x_{k + 1}, \cdots, x_l] - f[x_k, \cdots, x_{l - 1}]}{x_l - x_k}\] \[f[x_k, \cdots, x_l] = f[x_l, \cdots, x_k]\] \[a_i = f[x_0, x_1, \cdots, x_i]\]<p>위 정의를 종합하면 뉴턴 다항식을 조금 쉽게 풀어 쓸 수 있다.</p>\[\begin{aligned} N(x) &amp;= a_0 + a_1(x - x_0) + a_2(x - x_0)(x - x_1) + \cdots + a_n(x - x_0)(x - x_1)\cdots(x - x_{n - 1}) \\ &amp;= f[x_0] + f[x_0, x_1] (x - x_0) + f[x_0, x_1, x_2] (x - x_0)(x - x_1)+ \cdots \\ &amp;+ f[x_0, x_1, \cdots, x_n] (x - x_0)(x - x_1)\cdots(x - x_{n - 1}) \end{aligned}\]<h2 id="how-to-calculate-divided-differences"><span class="mr-2">How to calculate Divided Differences</span><a href="#how-to-calculate-divided-differences" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>앞의 <a href="#definition">Definition</a>에서는 $n + 1$개의 Point가 있다고 가정했지만 지금부터는 $n$개의 데이터가 있으며 모든 인덱스는 0부터 시작한다고 가정할 것이다. 이는 코딩의 편의성을 위해서이다. 즉, 주어진 Point는 아래와 같다고 가정한다.</p>\[(x_0, y_0), (x_1, y_1), \cdots, (x_{n - 1}, y_{n - 1})\]<h3 id="분할차분-정의-해석"><span class="mr-2">분할차분 정의 해석</span><a href="#분할차분-정의-해석" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>분할차분의 정의 중 아래 식에서 한가지 특징을 알 수 있다.</p>\[f[x_k, x_{k + 1}, \cdots, x_l] = \displaystyle\frac{f[x_{k + 1}, \cdots, x_l] - f[x_k, \cdots, x_{l - 1}]}{x_l - x_k}\]<p>$l &gt; k$라고 가정 할 때 좌측 항의 분할차분의 경우 $x_k, \cdots, x_l$까지 총 $l - k + 1$개의 $x$를 참조하지만 (설명의 편의를 위해 참조란 용어를 사용했지만 실제로 각 $x_i$의 값을 직접 참조하는 것은 아니다), 우측 항에서는 각 2개의 분할차분 모두 1개가 줄어든 $l - k$개의 $x$를 참조한다. 즉, 식을 전개할 수록 $x$를 참조하는 일종의 스케일이 줄어드는 재귀적 관계이다. 다만 아직까지 감이 안잡힐 수도 있으니 간단한 예를 들어보겠다.</p>\[f[x_0, x_1, x_2] = \displaystyle\frac{f[x_1, x_2] - f[x_0, x_1]}{x_2 - x_0}\]<p>위 식에서 $k = 0, l = 2$이다. 좌측항은 $x_0, x_1, x_2$를 참조하지만 우측항의 분할차분은 각각 $x_0, x_1$와 $x_1, x_2$를 참조한다. 위 식의 우측항에 있는 각각의 분할차분 식을 다시 아래에 전개해보겠다.</p>\[f[x_1, x_2] = \displaystyle\frac{f[x_2] - f[x_1]}{x_2 - x_1}\] \[f[x_0, x_1] = \displaystyle\frac{f[x_1] - f[x_0]}{x_1 - x_0}\]<p>위 식에서 또다시 스케일이 줄어들었다. $f[x_k] = f(x_0)$로 분할차분이 최소단위가 됬음을 확인할 수 있다.</p><h3 id="분할차분-계산"><span class="mr-2">분할차분 계산</span><a href="#분할차분-계산" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>이제 본격적으로 위 예를 가지고 분할차분 값을 계산해보겠다. 아래 분할차분의 정의를 활용하는 것으로부터 분할차분 계산을 시작할 수 있다.</p>\[f[x_k] = f(x_k)\]<p>위 정의를 활용하면 각각의 분할차분을 계산할 수 있다.</p>\[f[x_1, x_2] = \displaystyle\frac{f[x_2] - f[x_1]}{x_2 - x_1} = \displaystyle\frac{f(x_2) - f(x_1)}{x_2 - x_1}\] \[f[x_0, x_1] = \displaystyle\frac{f[x_1] - f[x_0]}{x_1 - x_0} = \displaystyle\frac{f(x_1) - f(x_0)}{x_1 - x_0}\]<p>우리는 $x$좌표와 그에 대응하는 함수값 $f(x)$또는 $y$좌표를 이미 알고 있다. 따라서 위 분할차분을 계산할 수 있다. 참고로 위 분할차분의 특징은 함수의 평균변화율 혹은 두 점 사이의 직선의 기울기이다. 필요한 2개의 분할차분 값을 구했으니 이를 활용해 다음 분할차분값을 드디어 구할 수 있다.</p>\[f[x_0, x_1, x_2] = \displaystyle\frac{f[x_1, x_2] - f[x_0, x_1]}{x_2 - x_0}\]<p>위 식에서 $f[x_1, x_2]$와 $f[x_0, x_1]$는 이미 구해서 알고 있고 $x$좌표 역시 원래 알고 있던 값이므로 $f[x_0, x_1, x_2]$ 값을 구하는 거는 단순 계산일 뿐이다.</p><p>우리는 지금까지 분할차분을 구하는 방법을 알아보았다. 하지만 위 방식만 가지고는 구하기도 다소 어렵고, 코딩에 적용하기도 쉽지 않다. 따라서 우리는 분할차분표라는 개념을 도입해 문제를 쉽게 해결해보려 한다.</p><h2 id="divided-differences-table"><span class="mr-2">Divided Differences Table</span><a href="#divided-differences-table" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Divided Differences Table은 분할차분표로 위에서 소개한 bottom-up 방식의 계산을 table 형태의 자료구조를 통해 쉽게 계산할 수 있도록 해주는 방법이다. 표의 형태는 아래와 같다.</p><p>분할차분표:</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">$x_i$<th style="text-align: center">$f[x_i]$<th style="text-align: center">$f[x_i, x_{i + 1}]$<th style="text-align: center">$f[x_i, x_{i + 1}, x_{i + 2}]$<th style="text-align: center">$f[x_i, x_{i + 1}, x_{i + 2}]$<th style="text-align: center">$\cdots$<th style="text-align: center">$f[x_i, \cdots, x_{i + (n - 1)}]$<tbody><tr><td style="text-align: center">$x_0$<td style="text-align: center">$f(x_0)$<td style="text-align: center">$f[x_0, x_1]$<td style="text-align: center">$f[x_0, x_1, x_2]$<td style="text-align: center">$f[x_0, x_1, x_2, x_3]$<td style="text-align: center">$\cdots$<td style="text-align: center">$f[x_0, x_1, \cdots, x_{n - 1}]$<tr><td style="text-align: center">$x_1$<td style="text-align: center">$f(x_1)$<td style="text-align: center">$f[x_1, x_2]$<td style="text-align: center">$f[x_1, x_2, x_3]$<td style="text-align: center">$\vdots$<td style="text-align: center"> <td style="text-align: center"> <tr><td style="text-align: center">$x_2$<td style="text-align: center">$f(x_2)$<td style="text-align: center">$f[x_2, x_3]$<td style="text-align: center">$\vdots$<td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center"> <tr><td style="text-align: center">$x_3$<td style="text-align: center">$f(x_3)$<td style="text-align: center">$\vdots$<td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center"> <tr><td style="text-align: center">$\vdots$<td style="text-align: center">$\vdots$<td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center"> <tr><td style="text-align: center">$x_{n - 1}$<td style="text-align: center">$f(x_{n - 1})$<td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center"> </table></div><p>$n$개의 Point(점)가 있고, 분할차분표의 행 인덱스는 $i$, 열 인덱스는 $j$이며 0부터 시작한다. 위 분할차분표의 특징은 아래와 같다.</p><ul><li>분할차분 값에 해당되는 부분은 $n \times n$ table로 구성된다.<li>각 열의 원소 개수는 $n$개에서 $j$개씩 감소한다. 즉, $n - j$개이다.</ul><h3 id="분할차분표를-이용한-계산"><span class="mr-2">분할차분표를 이용한 계산</span><a href="#분할차분표를-이용한-계산" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>분할차분표를 활용해 분할차분을 쉽게 계산하는 방법을 소개한다. <a href="#분할차분-계산">분할차분 계산</a>에서 들었던 예시를 분할차분표를 이용해 구해보겠다. 또한 이해를 돕기 위해 표에 행과 열에 대한 인덱스를 추가했다.</p><p>가장 먼저 우리가 이미 알고 있는 값인 Point의 $x$좌표와 $y$좌표를 표에 넣는다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"> <th style="text-align: center">Column<th style="text-align: center">0<th style="text-align: center">1<th style="text-align: center">2<tr><th style="text-align: center">Row<th style="text-align: center">$x_i$<th style="text-align: center">$f[x_i]$<th style="text-align: center">$f[x_i, x_{i + 1}]$<th style="text-align: center">$f[x_i, x_{i + 1}, x_{i + 2}]$<tbody><tr><td style="text-align: center">0<td style="text-align: center">$x_0$<td style="text-align: center">$f(x_0)$<td style="text-align: center"> <td style="text-align: center"> <tr><td style="text-align: center">1<td style="text-align: center">$x_1$<td style="text-align: center">$f(x_1)$<td style="text-align: center"> <td style="text-align: center"> <tr><td style="text-align: center">2<td style="text-align: center">$x_2$<td style="text-align: center">$f(x_2)$<td style="text-align: center"> <td style="text-align: center"> </table></div><p><a href="#분할차분-계산">분할차분 계산</a>에서 이미 봤듯이 분할차분 값을 계산하는 핵심은 이전의 분할차분 값을 이용하는 거다. 이 때 현재 열의 분할차분 값을 구하기 위해서는 직전 열의 바로 옆에 있는 값과 그 아래 값을 이용한다. 즉, $i$행 $j$열의 분할차분 값을 구하기 위해서 $i$행 $j - 1$열의 값과 $i + 1$행 $j - 1$열의 분할차분 값을 참조한다. 아래 표를 보면 조금 더 쉽게 이해할 수 있다. 참조해야하는 분할차분 값에 화살표를 그렸다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"> <th style="text-align: center">Column<th style="text-align: center">0<th style="text-align: center">1<th style="text-align: center">2<tr><th style="text-align: center">Row<th style="text-align: center">$x_i$<th style="text-align: center">$f[x_i]$<th style="text-align: center">$f[x_i, x_{i + 1}]$<th style="text-align: center">$f[x_i, x_{i + 1}, x_{i + 2}]$<tbody><tr><td style="text-align: center">0<td style="text-align: center">$x_0$<td style="text-align: center">$f(x_0)$ $\rightarrow$<td style="text-align: center">$f[x_0, x_1] = \displaystyle\frac{f[x_1] - f[x_0]}{x_1 - x_0}$<td style="text-align: center"> <tr><td style="text-align: center">1<td style="text-align: center">$x_1$<td style="text-align: center">$f(x_1)$ $\nearrow$<td style="text-align: center"> <td style="text-align: center"> <tr><td style="text-align: center">2<td style="text-align: center">$x_2$<td style="text-align: center">$f(x_2)$<td style="text-align: center"> <td style="text-align: center"> </table></div><div class="table-wrapper"><table><thead><tr><th style="text-align: center"> <th style="text-align: center">Column<th style="text-align: center">0<th style="text-align: center">1<th style="text-align: center">2<tr><th style="text-align: center">Row<th style="text-align: center">$x_i$<th style="text-align: center">$f[x_i]$<th style="text-align: center">$f[x_i, x_{i + 1}]$<th style="text-align: center">$f[x_i, x_{i + 1}, x_{i + 2}]$<tbody><tr><td style="text-align: center">0<td style="text-align: center">$x_0$<td style="text-align: center">$f(x_0)$<td style="text-align: center">$f[x_0, x_1] = \displaystyle\frac{f[x_2] - f[x_0]}{x_1 - x_0}$<td style="text-align: center"> <tr><td style="text-align: center">1<td style="text-align: center">$x_1$<td style="text-align: center">$f(x_1)$ $\rightarrow$<td style="text-align: center">$f[x_1, x_2] = \displaystyle\frac{f[x_2] - f[x_1]}{x_2 - x_1}$<td style="text-align: center"> <tr><td style="text-align: center">2<td style="text-align: center">$x_2$<td style="text-align: center">$f(x_2)$ $\nearrow$<td style="text-align: center"> <td style="text-align: center"> </table></div><p>이제 위에서 구한 두 분할차분 값 $f[x_0, x_1]$과 $f[x_1, x_2]$를 가지고 $f[x_0, x_1, x_2]$를 구하면 된다. 또한 분모의 경우 $f[x_0, x_1, x_2]$에서 맨 왼쪽의 $x_0$와 맨 오른쪽의 $x_2$의 값의 차인 $x_2 - x_0$로 구할 수 있다. 분모가 왜 이렇게 구해지는지 기억이 나지 않을 경우 <a href="#분할차분-정의-해석">분할차분 정의 해석</a>을 보고 오기 바란다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"> <th style="text-align: center">Column<th style="text-align: center">0<th style="text-align: center">1<th style="text-align: center">2<tr><th style="text-align: center">Row<th style="text-align: center">$x_i$<th style="text-align: center">$f[x_i]$<th style="text-align: center">$f[x_i, x_{i + 1}]$<th style="text-align: center">$f[x_i, x_{i + 1}, x_{i + 2}]$<tbody><tr><td style="text-align: center">0<td style="text-align: center">$x_0$<td style="text-align: center">$f(x_0)$<td style="text-align: center">$f[x_0, x_1]$ $\rightarrow$<td style="text-align: center">$f[x_0, x_1, x_2] = \displaystyle\frac{f[x_1, x_2] - f[x_0, x_1]}{x_2 - x_0}$<tr><td style="text-align: center">1<td style="text-align: center">$x_1$<td style="text-align: center">$f(x_1)$<td style="text-align: center">$f[x_1, x_2]$ $\nearrow$<td style="text-align: center"> <tr><td style="text-align: center">2<td style="text-align: center">$x_2$<td style="text-align: center">$f(x_2)$<td style="text-align: center"> <td style="text-align: center"> </table></div><p>이제 우리는 뉴턴 다항식 보간을 위해 필요한 모든 분할차분 값을 구할 수 있게 되었다.</p><h3 id="분할차분표를-활용해-다항식-보간하기"><span class="mr-2">분할차분표를 활용해 다항식 보간하기</span><a href="#분할차분표를-활용해-다항식-보간하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>뉴턴 다항식은 앞에서 봤지만 다시 Remind하자. 앞의 정의에서는 $n + 1$개의 Point였지만 지금은 $n$개의 Point이기 때문에 개수에 맞춰서 식을 다시 작성했다.</p>\[\begin{aligned} N(x) &amp;= f[x_0] + f[x_0, x_1] (x - x_0) + f[x_0, x_1, x_2] (x - x_0)(x - x_1)+ \cdots \\ &amp;+ f[x_0, x_1, \cdots, x_{n - 1}] (x - x_0)(x - x_1)\cdots(x - x_{n - 2}) \end{aligned}\]<p>뉴턴 다항식에서 $k$가 $0 \leq k \leq n - 1$ 조건을 만족할 때, $k$번째 항의 계수는 $f[x_0, \cdots, x_k]$이며 모든 항의 계수인 분할차분은 $x_0$부터 시작한다. 분할 차분표에서 $i$행 $j$열의 분할차분은 $f[x_i, \cdots, x_{i + j}]$이다. 즉, 뉴턴 다항식의 $k$번째 항의 계수는 0행 $k$열의 분할차분 값이다.</p><p>아래는 앞서 구한 분할차분표 예시이다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"> <th style="text-align: center">Column<th style="text-align: center">0<th style="text-align: center">1<th style="text-align: center">2<tr><th style="text-align: center">Row<th style="text-align: center">$x_i$<th style="text-align: center">$f[x_i]$<th style="text-align: center">$f[x_i, x_{i + 1}]$<th style="text-align: center">$f[x_i, x_{i + 1}, x_{i + 2}]$<tbody><tr><td style="text-align: center">0<td style="text-align: center">$x_0$<td style="text-align: center">0번째 항의 계수: $f(x_0)$<td style="text-align: center">1번째 항의 계수: $f[x_0, x_1]$<td style="text-align: center">2번째 항의 계수: $f[x_0, x_1, x_2]$<tr><td style="text-align: center">1<td style="text-align: center">$x_1$<td style="text-align: center">$f(x_1)$<td style="text-align: center">$f[x_1, x_2]$<td style="text-align: center"> <tr><td style="text-align: center">2<td style="text-align: center">$x_2$<td style="text-align: center">$f(x_2)$<td style="text-align: center"> <td style="text-align: center"> </table></div><p>위 분할차분표를 가지고 뉴턴 다항식을 보간하면 아래와 같다.</p>\[N(x) = f(x_0) + f[x_0, x_1] (x - x_0) + f[x_0, x_1, x_2] (x - x_0)(x - x_1)\]<p>임의의 점 3개가 주어졌을 때 분할차분표를 활용하면 위와 같이 2차함수로 보간할 수 있다.</p><p>거창하게 뉴턴 다항식, 분할차분과 같은 어려운 개념을 봤지만, 결국 우리가 구한 식을 보면 단순한 다항식이다. 나름 굉장히 복잡한 원리를 통해서 다항식을 도출해지만 사실 다항식을 구하는 방법은 <a href="#introduction">Introduction</a>에서 말했듯이 단순하게 $y = a_0 + a_1x + a_2x^2 + \cdots$ 형태의 방정식에 지나는 점을 대입해 각 항의 계수를 구하는 것이 훨씬 쉽고 간편하다. 하지만 이 방법은 코딩 시 <a href="https://en.wikipedia.org/wiki/Gaussian_elimination">가우스 소거법</a>과 같은 행렬 연산을 통해 방정식을 풀어야 하는데, 데이터의 개수가 많아질 경우 오차에도 취약해지고 속도가 굉장히 느려진다. 따라서 더 나은 대안인 뉴턴 다항식 보간을 활용하는 것이다.</p><h2 id="algorithm"><span class="mr-2">Algorithm</span><a href="#algorithm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>지금까지 분할차분의 개념, 분할차분표를 통한 분할차분의 계산, 뉴턴 다항식 보간 등을 알아보았다. 이제 뉴턴 다항식 보간에 대한 알고리즘을 소개하고 이를 코딩해보려 한다. 알고리즘은 아래와 같다.</p><blockquote><h5 id="textalgorithm-newton-polynomial-interpolation"><span class="mr-2">$\text{Algorithm: Newton polynomial interpolation}$</span><a href="#textalgorithm-newton-polynomial-interpolation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>\(\begin{align*} &amp; \textstyle \text{Input: a point set } P = (x_0, y_0), \cdots, (x_{n-1}, y_{n-1}) \text{ of } n \text{ points, target } x \\ &amp; \textstyle \text{Initialize a } n \times n \text{ table } T \in \mathbb{R}^{n \times n}, \ T_{i,0} \leftarrow y_i \text{ for all } i \\ \\ &amp; \textstyle \text{for } j = 1 \text{ to } n - 1 \text{ do} \\ &amp; \textstyle \qquad \text{for } i = 0 \text{ to } n - 1 - j \text{ do} \\ &amp; \textstyle \qquad\qquad T_{i,j} \leftarrow (T_{i+1,j-1} - T_{i,j-1}) / (x_{i+j} - x_i) \\ &amp; \textstyle \qquad \text{end} \\ &amp; \textstyle \text{end} \\ \\ &amp; \textstyle N \leftarrow 0 \\ &amp; \textstyle p \leftarrow 1 \\ &amp; \textstyle \text{for } i = 0 \text{ to } n - 1 \text{ do} \\ &amp; \textstyle \qquad N \leftarrow N + T_{0,i} \times p \\ &amp; \textstyle \qquad p \leftarrow p \times (x - x_{i}) \\ &amp; \text{end} \\ \\ &amp; \textstyle \text{return } N \end{align*}\)</p></blockquote><p>위 알고리즘을 활용해 실제 코드로 구현해보자.</p><h2 id="python-code"><span class="mr-2">Python Code</span><a href="#python-code" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="#algorithm">Algorithm</a>의 내용을 Python 코드로 구현한다. <a href="https://numpy.org/">Numpy</a> library를 활용하였다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
</pre></table></code></div></div><h3 id="분할차분표-method---python"><span class="mr-2">분할차분표 Method - Python</span><a href="#분할차분표-method---python" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>point set <code class="language-plaintext highlighter-rouge">points</code>을 입력하면 분할차분표를 계산 후 반환한다. Numpy의 장점을 활용하기 위해 <a href="#algorithm">Algorithm</a> 파트와 같이 중첩 for문을 사용하지 않고 각 열에 대해 vectorization 기법을 활용하여 계산하였다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">divided_differences_table</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">points</span><span class="p">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">points</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
    
    <span class="n">x</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">points</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Initialize divided differences table
</span>    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">T</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">j</span> <span class="c1"># last row of a current colummn
</span>        <span class="n">T</span><span class="p">[:</span><span class="n">l</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">T</span><span class="p">[:</span><span class="n">l</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="n">l</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:</span><span class="n">l</span><span class="p">])</span>
        
    <span class="k">return</span> <span class="n">T</span>
</pre></table></code></div></div><p>위 for문에서 지역변수 <code class="language-plaintext highlighter-rouge">l</code>은 현재 분할차분을 계산하려는 열에 대해 마지막 행으로 <code class="language-plaintext highlighter-rouge">i</code>로 생각하면 사실상 수식은 동일하다.</p><h3 id="뉴턴-다항식-보간---python"><span class="mr-2">뉴턴 다항식 보간 - Python</span><a href="#뉴턴-다항식-보간---python" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">newton_poly()</code>는 입력된 point set <code class="language-plaintext highlighter-rouge">points</code>에 대해 뉴턴 다항식을 반환하는 method이다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">newton_poly</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">points</span><span class="p">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">points</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
    
    <span class="n">T</span> <span class="o">=</span> <span class="n">divided_differences_table</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">coef</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="c1"># coefficients from the first row of divided differences table
</span>    <span class="n">x_values</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">except</span> <span class="nb">TypeError</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coef</span><span class="p">)):</span>
            <span class="n">N</span> <span class="o">+=</span> <span class="n">coef</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span>
            <span class="n">p</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">N</span>
    
    <span class="k">return</span> <span class="n">interpolate</span>
</pre></table></code></div></div><p>위에서 정의한 <code class="language-plaintext highlighter-rouge">divided_differences_table()</code> method를 통해 분할차분표를 획득한 뒤 뉴턴 다항식 보간에 사용할 계수를 추출한다. local function <code class="language-plaintext highlighter-rouge">interpolate()</code>에 <code class="language-plaintext highlighter-rouge">coef</code>와 <code class="language-plaintext highlighter-rouge">x_values</code>를 capture 시킨 뒤 뉴턴 다항식을 계산 방법을 기술한다. 이 때 <code class="language-plaintext highlighter-rouge">interpolate()</code>의 입력 <code class="language-plaintext highlighter-rouge">x</code>에도 vectorization을 지원하기 위해 Numpy의 utility function들을 활용하였다. 그 후 <code class="language-plaintext highlighter-rouge">interpolate()</code> local function 자체를 반환하면 입력된 point set에 대한 뉴턴 다항식 자체를 획득할 수 있다.</p><h3 id="뉴턴-다항식-보간-최종-코드---python"><span class="mr-2">뉴턴 다항식 보간 최종 코드 - Python</span><a href="#뉴턴-다항식-보간-최종-코드---python" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>위 내용을 정리한 코드이다.</p><script src="https://gist.github.com/DevSlem/f47820db6203e0b7d91cc1334d0aa76a.js"></script><h3 id="디버깅---python"><span class="mr-2">디버깅 - Python</span><a href="#디버깅---python" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>디버깅을 위해 우리가 잘 알고 있는 3차함수인 $y = x(x - 1)(x + 1)$를 지나는 Point들을 <code class="language-plaintext highlighter-rouge">Point2</code> 타입의 배열을 만들고 초기화 한다. 점이 4개이기 때문에 3차함수를 보간할 수 있다.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>

<span class="n">func</span> <span class="o">=</span> <span class="n">newton_poly</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">func</span><span class="p">([</span><span class="o">-</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]))</span>
</pre></table></code></div></div><p>출력된 결과는 다음과 같다.</p><p><img data-src="/assets/images/newton-poly-python-result.png" alt="" data-proofer-ignore></p><p>보간하고자 했던 함수에 동일한 $x$값인 -2와 3을 대입해보면 동일한 함숫값을 얻을 수 있다. 즉, 성공적으로 다항식을 보간했다. 이제 어떤 임의의 점이든지 간에 그 점들을 지나는 유일한 다항함수를 결정할 수 있다.</p><h3 id="matplotlib로-뉴턴-다항식-그래프-출력---python"><span class="mr-2">Matplotlib로 뉴턴 다항식 그래프 출력 - Python</span><a href="#matplotlib로-뉴턴-다항식-그래프-출력---python" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>위 보간된 뉴턴 다항식을 그래프로도 확인해보자.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s">"r"</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">"o"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</pre></table></code></div></div><p>뉴턴 다항식 그래프:</p><p><img data-src="/assets/images/newton-poly-python-graph.png" alt="" width="50%" data-proofer-ignore></p><p>보간된 뉴턴 다항식은 주어진 point set <code class="language-plaintext highlighter-rouge">p</code>를 지나감을 확인할 수 있다.</p><h2 id="c-code"><span class="mr-2">C# Code</span><a href="#c-code" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Unity에서 사용해 보기 위해 C#으로도 구현해보았다.</p><h3 id="사용자-정의-타입-선언---c"><span class="mr-2">사용자 정의 타입 선언 - C#</span><a href="#사용자-정의-타입-선언---c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>먼저 2차원 상의 Point의 위치를 표현할 수 있는 <code class="language-plaintext highlighter-rouge">Point2</code> struct를 정의한다.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Vector2</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Vector2</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>다음은 입력으로 $x$값을 받고, 출력으로 함숫값을 반환하는 <code class="language-plaintext highlighter-rouge">delegate</code>를 선언한다. <code class="language-plaintext highlighter-rouge">delegate</code> 타입은 <code class="language-plaintext highlighter-rouge">InterpolatedFunction</code>이라고 명칭하겠다. 이는 뉴턴 다항식 보간 시 <strong>보간된 다항식을 반환</strong>하기 위한 대리자이다.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// 입력: x, 출력: f(x)</span>
<span class="k">delegate</span> <span class="kt">float</span> <span class="nf">InterpolatedFunction</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="뉴턴-다항식-보간-메소드-선언---c"><span class="mr-2">뉴턴 다항식 보간 메소드 선언 - C#</span><a href="#뉴턴-다항식-보간-메소드-선언---c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>구현하려는 뉴턴 다항식 보간 메소드의 형식은 다음과 같다.</p><ul><li><code class="language-plaintext highlighter-rouge">Point2</code> 타입의 배열을 <code class="language-plaintext highlighter-rouge">points</code> 매개변수에 입력받는다. <code class="language-plaintext highlighter-rouge">points</code> 배열은 <strong>Point</strong>의 집합이다.<li><code class="language-plaintext highlighter-rouge">points</code> 배열의 각 점을 지나는 다항식 험수를 보간 후 <strong>보간된 다항식을 반환</strong>한다.</ul><p>위 내용을 수학적으로 정리하면 다음과 같다.</p><ul><li>입력: points 배열<br /> $(x_0, y_0), (x_1, y_1), \cdots$<li>출력: 보간된 뉴턴 다항식<br /> $N(x) = f[x_0] + f[x_0, x_1] (x - x_0) + f[x_0, x_1, x_2] (x - x_0)(x - x_1)+ \cdots$</ul><p>즉, 위 $N(x)$ 함수를 <code class="language-plaintext highlighter-rouge">InterpolatedFunction</code> delegate에 할당 후 반환하려는 것이다. 아래는 뉴턴 다항식 보간 메소드이다.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="n">InterpolatedFunction</span> <span class="nf">NewtonPolynomial</span><span class="p">(</span><span class="k">params</span> <span class="n">Vector2</span><span class="p">[]</span> <span class="n">points</span><span class="p">)</span> <span class="p">{</span>  <span class="p">}</span>
</pre></table></code></div></div><p>이제 위 메소드를 구현할 시간이다.</p><h3 id="분할차분표-생성-및-초기화---c"><span class="mr-2">분할차분표 생성 및 초기화 - C#</span><a href="#분할차분표-생성-및-초기화---c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>먼저 분할차분표를 <strong>2차원 배열</strong>로 구현한다. $n$개의 Point가 주어졌다면 $n - 1$차 다항식을 보간할 수 있으며 분할차분표의 크기는 $n$행 $n$열이다. 이 때 각 행과 열의 인덱스 범위는 $0 \leq i, j \leq n - 1$이다. 분할차분표에는 $x$좌표는 들어가지 않으며 <strong>오직 분할차분 값만 들어간다</strong>.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="n">points</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="c1">// Point의 개수</span>
<span class="kt">float</span><span class="p">[,]</span> <span class="n">dividedDifferenceTable</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">];</span> <span class="c1">// n행 n열 크기의 분할차분표</span>
</pre></table></code></div></div><p>분할차분표의 0번째 열은 $f[x_i] = f(x_i)$이므로 각 Point의 $y$좌표(또는 함수값)을 대입한다.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// 0번째 열에 y좌표(함수값) 대입</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">dividedDifferenceTable</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>$i$행 $j$열의 분할차분 값은 $i + 1$행 $j - 1$열의 분할차분과 $i$행 $j - 1$열의 분할차분을 통해 구한다. 즉, 분할차분표의 $i$행 $j$열의 값을 $T_{i, j}$라고 할 때 $T_{i, j} = \displaystyle\frac{T_{i + 1, j - 1} - T_{i, j - 1}}{x_{i + j} - x_i}$이다. 또한 $i + 1$행 $j - 1$열의 분할차분 참조로 인해 각 열의 원소 개수는 $n - j$개다. 따라서 각 열에 대해 $i$는 $0$부터 $n - 1 - j$까지 참조한다. 내용이 잘 이해되지 않는다면 <a href="#분할차분표를-이용한-계산">분할차분표를 이용한 계산</a>을 다시 보길 권장한다.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// 분할 차분 값들을 이전 분할 차분 값으로부터 순차적으로 구함</span>
<span class="c1">// 0번째 열은 이미 구했으므로 j = 1부터 시작</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span> <span class="n">j</span> <span class="p">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">n</span> <span class="p">-</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">dividedDifferenceTable</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="n">dividedDifferenceTable</span><span class="p">[</span><span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">j</span> <span class="p">-</span> <span class="m">1</span><span class="p">]</span> <span class="p">-</span> <span class="n">dividedDifferenceTable</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="p">-</span> <span class="m">1</span><span class="p">])</span> <span class="p">/</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span> <span class="p">+</span> <span class="n">j</span><span class="p">].</span><span class="n">x</span> <span class="p">-</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="뉴턴-다항식-보간---c"><span class="mr-2">뉴턴 다항식 보간 - C#</span><a href="#뉴턴-다항식-보간---c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>분할차분표를 완성했기 때문에 이제 뉴턴 다항식을 보간할 수 있다. <strong>분할차분표의 0번째 행이 뉴턴 다항식의 각 항의 계수</strong>이다. 메모리 효율성을 위해 전처리로 분할차분표의 0번째 행과 Points의 $x$값들을 따로 복사한다. 그 이유는 delegate나 local function 사용 시 변수를 캡쳐할 때 발생하는 몇가지 문제 때문이다. 자세한 내용은 C# 클로저 개념을 참조하면 되며 이 포스트의 주 목적은 아니기 때문에 크게 신경쓰지 않아도 된다.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// 보간하려는 다항함수의 계수: 분할차분표의 0번째 행</span>
<span class="kt">float</span><span class="p">[]</span> <span class="n">coef</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">coef</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">dividedDifferenceTable</span><span class="p">[</span><span class="m">0</span><span class="p">,</span> <span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// 필요한 데이터의 x값(마지막 x값은 필요 없음)</span>
<span class="kt">float</span><span class="p">[]</span> <span class="n">x_points</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">x_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>뉴턴 다항식을 구하는 <code class="language-plaintext highlighter-rouge">Interpolate()</code> local function 내부에서 뉴턴 다항식 $N(x) = f[x_0] + f[x_0, x_1] (x - x_0) + f[x_0, x_1, x_2] (x - x_0)(x - x_1) + \cdots$ 와 같이 각 항의 차수가 순차적으로 증가하는 형태로 다항식을 보간한다. 이 때 위에서 복사한 값을 활용해 뉴턴 다항식을 보간할 수 있다.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="nf">Interpolate</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">functionValue</span> <span class="p">=</span> <span class="m">0f</span><span class="p">;</span> <span class="c1">// 반환할 함수값</span>
    <span class="kt">float</span> <span class="n">newtonBasisPoly</span> <span class="p">=</span> <span class="m">1f</span><span class="p">;</span> <span class="c1">// 뉴턴 기반 다항식</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">coef</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">functionValue</span> <span class="p">+=</span> <span class="n">coef</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">*</span> <span class="n">newtonBasisPoly</span><span class="p">;</span>
        <span class="n">newtonBasisPoly</span> <span class="p">*=</span> <span class="n">x</span> <span class="p">-</span> <span class="n">x_points</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// 누적곱을 사용함</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">functionValue</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>local function <code class="language-plaintext highlighter-rouge">Interpolate()</code>를 <code class="language-plaintext highlighter-rouge">InterpolatedFunction</code> delegate 인스턴스에 할당 후 반환한다. 이렇게 처리하는 목적은 동일한 data set에 대해 중복해서 분할차분표를 구하는 낭비를 피하기 위해서이다.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">return</span> <span class="k">new</span> <span class="nf">InterpolatedFunction</span><span class="p">(</span><span class="n">Interpolate</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="뉴턴-다항식-보간-최종-코드---c"><span class="mr-2">뉴턴 다항식 보간 최종 코드 - C#</span><a href="#뉴턴-다항식-보간-최종-코드---c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>위 내용을 정리한 코드이다.</p><script src="https://gist.github.com/DevSlem/a5b6815c5c06b6399ff140d969692790.js"></script><h3 id="디버깅---c"><span class="mr-2">디버깅 - C#</span><a href="#디버깅---c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>디버깅을 위해 우리가 잘 알고 있는 3차함수인 $y = x(x - 1)(x + 1)$를 지나는 Point들을 <code class="language-plaintext highlighter-rouge">Point2</code> 타입의 배열을 만들고 초기화 한다. 점이 4개이기 때문에 3차함수를 보간할 수 있다.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Vector2</span><span class="p">[]</span> <span class="n">points</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector2</span><span class="p">[</span><span class="m">4</span><span class="p">]</span>
    <span class="p">{</span>
        <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span>
        <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span>
        <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span>
        <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">6</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="kt">var</span> <span class="n">f</span> <span class="p">=</span> <span class="nf">NewtonPolynomial</span><span class="p">(</span><span class="n">points</span><span class="p">);</span> <span class="c1">// 뉴턴 다항식 보간 메소드 호출</span>

    <span class="c1">// 결과: (-2, -6), (3, 24)</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"(</span><span class="p">{-</span><span class="m">2</span><span class="p">}</span><span class="s">, </span><span class="p">{</span><span class="nf">f</span><span class="p">(-</span><span class="m">2</span><span class="p">)}</span><span class="s">), (</span><span class="p">{</span><span class="m">3</span><span class="p">}</span><span class="s">, </span><span class="p">{</span><span class="nf">f</span><span class="p">(</span><span class="m">3</span><span class="p">)}</span><span class="s">)"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>출력된 결과는 다음과 같다.</p>\[(-2, -6), (3, 24)\]<p>보간하고자 했던 함수에 동일한 $x$값인 -2와 3을 대입해보면 동일한 함숫값을 얻을 수 있다. 즉, 성공적으로 다항식을 보간했다. 이제 어떤 임의의 점이든지 간에 그 점들을 지나는 유일한 다항함수를 결정할 수 있다.</p><h3 id="unity에서-구현한-비선형-오브젝트함정---c"><span class="mr-2">Unity에서 구현한 비선형 오브젝트(함정) - C#</span><a href="#unity에서-구현한-비선형-오브젝트함정---c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Unity Object를 주어진 데이터에 의해 보간된 비선형 함수의 궤적을 따라 움직이도록 구현하였다.</p><h4 id="인스펙터-설정"><span class="mr-2">인스펙터 설정</span><a href="#인스펙터-설정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>데이터 입력과 보간, 이동 기능은 아래 <code class="language-plaintext highlighter-rouge">Non Linear Movable Object</code> 컴포넌트에서 처리했다.</p><ul><li><p>4개의 점을 입력해 각 점을 지나는 <strong>3차함수</strong>를 보간한다. <img data-src="/assets/images/cubic-inspector.png" alt="3차함수 인스펙터" width="50%" data-proofer-ignore></p><li><p>5개의 점을 입력해 각 점을 지나는 <strong>4차함수</strong>를 보간한다. <img data-src="/assets/images/quaternary-inspector.png" alt="4차함수 인스펙터" width="50%" data-proofer-ignore></p></ul><h4 id="실제-이동-장면"><span class="mr-2">실제 이동 장면</span><a href="#실제-이동-장면" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>아래는 각각 3차함수와 4차함수의 궤적으로 움직이는 함정을 보여주는 장면이다.</p><p><img data-src="/assets/images/non-linear-trap.webp" alt="Non Linear Object" width="70%" data-proofer-ignore></p><p>직선 방향으로만 움직이는 함정보다 위와 같이 곡선 형태의 움직임을 취하면 좀 더 다양성을 줄 수 있고 게임 난이도도 올릴 수 있다.</p><h2 id="references"><span class="mr-2">References</span><a href="#references" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>[1] Wikipedia. <a href="https://en.wikipedia.org/wiki/Newton_polynomial">Newton polynomial</a>.<br /> [2] INU. Jibum Kim. 수치해석 lecture.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/numerical-analysis/'>Numerical Analysis</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/interpolation/" class="post-tag no-text-decoration" >Interpolation</a> <a href="/tags/algorithm/" class="post-tag no-text-decoration" >Algorithm</a> <a href="/tags/unity/" class="post-tag no-text-decoration" >Unity</a> <a href="/tags/c/" class="post-tag no-text-decoration" >C#</a> <a href="/tags/python/" class="post-tag no-text-decoration" >Python</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5B%EC%88%98%EC%B9%98%ED%95%B4%EC%84%9D%5D+%EB%89%B4%ED%84%B4+%EB%8B%A4%ED%95%AD%EC%8B%9D+%EB%B3%B4%EA%B0%84%EB%B2%95+-+DevSlem+Blog&url=https%3A%2F%2Fdevslem.github.io%2Fnumerical-analysis%2Fnewton-polynomial%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%5B%EC%88%98%EC%B9%98%ED%95%B4%EC%84%9D%5D+%EB%89%B4%ED%84%B4+%EB%8B%A4%ED%95%AD%EC%8B%9D+%EB%B3%B4%EA%B0%84%EB%B2%95+-+DevSlem+Blog&u=https%3A%2F%2Fdevslem.github.io%2Fnumerical-analysis%2Fnewton-polynomial%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fdevslem.github.io%2Fnumerical-analysis%2Fnewton-polynomial%2F&text=%5B%EC%88%98%EC%B9%98%ED%95%B4%EC%84%9D%5D+%EB%89%B4%ED%84%B4+%EB%8B%A4%ED%95%AD%EC%8B%9D+%EB%B3%B4%EA%B0%84%EB%B2%95+-+DevSlem+Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div><script src="https://utteranc.es/client.js" repo="DevSlem/DevSlem.github.io" issue-term="pathname" label="comment" theme="github-dark" crossorigin="anonymous" async> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/reinforcement-learning/drl-methods/dqn/">DQN: Deep Q-Networks</a><li><a href="/reinforcement-learning/drl-methods/dtqn/">DTQN: Deep Transformer Q-Networks for Partially Observable Reinforcement Learning</a><li><a href="/wsl-setup/">Windows Subsystem for Linux (WSL) Setup for Reinforcement Learning</a><li><a href="/algorithm/sorting/merge-sort/">[알고리즘] 합병 정렬</a><li><a href="/algorithm/sorting/shell-sort/">[알고리즘] 쉘 정렬</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/rl/">RL</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/unity/">Unity</a> <a class="post-tag" href="/tags/function-approximation-rl/">Function Approximation RL</a> <a class="post-tag" href="/tags/sorting/">Sorting</a> <a class="post-tag" href="/tags/enemy/">Enemy</a> <a class="post-tag" href="/tags/game-development/">Game Development</a> <a class="post-tag" href="/tags/project/">Project</a> <a class="post-tag" href="/tags/attribute/">Attribute</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/unity/unity-projectile-motion/"><div class="card-body"> <em class="small" data-ts="1640271600" data-df="ll" > Dec 24, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Unity] 포물선 운동(점프) 구현</h3><div class="text-muted small"><p> 1. 개요 어떤 힘을 줘서 포물선 궤적으로 이동시키는 것 자체는 단순하다. 힘을 가하기만 하면 중력과의 상호작용에 의해 자연스럽게 포물선 운동을 한다. 하지만 내가 구현하고 싶은 것은 의도한 궤적으로 이동하는 포물선 운동이다. 단순히 힘을 주기만 하면 어느정도 높이로 올라가고 얼마나 멀리 가는지 알기 어렵다. 의도한 움직임을 구현할 수 있다면 더 정...</p></div></div></a></div><div class="card"> <a href="/algorithm/sorting/bubble-sort/"><div class="card-body"> <em class="small" data-ts="1666882800" data-df="ll" > Oct 28, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[알고리즘] 버블 정렬</h3><div class="text-muted small"><p> 버블 정렬은 인접한 두 원소를 비교하여 정렬하는 간단한 방식의 알고리즘이다. 버블 정렬의 특징은 아래와 같다. 비교 기반 in-place 시간 복잡도: $O(n^2)$ stable Key Idea 컨셉은 간단하다. 오름차순으로 정렬한다고 할 떄, $i$번째 원소와 $i+1$번째 원소를 비교해 $i$번째 원소가 더 크면 교환한다....</p></div></div></a></div><div class="card"> <a href="/algorithm/sorting/insertion-sort/"><div class="card-body"> <em class="small" data-ts="1666882800" data-df="ll" > Oct 28, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[알고리즘] 삽입 정렬</h3><div class="text-muted small"><p> 삽입 정렬은 선택된 원소를 이미 정렬된 영역에 삽입하는 방식의 간단한 정렬 알고리즘으로, 실제 사람이 카드 게임 시 카드를 정렬할 때와 유사한 방식이다. 특징은 아래와 같다. 비교 기반 in-place 시간 복잡도: $O(n^2)$ stable Key Idea 삽입 정렬의 과정은 아래와 같다. $i$번째 원소를 선택 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"><div class="btn btn-outline-primary disabled" prompt="Older"><p>-</p></div><a href="/unity/unity-first-game-mini-boss/" class="btn btn-outline-primary" prompt="Newer"><p>[Unity] 유니티 첫 게임 - 미니 보스</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/username">DevSlem</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/rl/">RL</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/unity/">Unity</a> <a class="post-tag" href="/tags/function-approximation-rl/">Function Approximation RL</a> <a class="post-tag" href="/tags/sorting/">Sorting</a> <a class="post-tag" href="/tags/enemy/">Enemy</a> <a class="post-tag" href="/tags/game-development/">Game Development</a> <a class="post-tag" href="/tags/project/">Project</a> <a class="post-tag" href="/tags/attribute/">Attribute</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] }, svg: { scale: 1.1 } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
